var bitwiseComplement = function(N) {
  return N.toString(2)
    .split("")
    .reduce((bef, cur, i) => {
      return cur === "0"
        ? bef + Math.pow(2, N.toString(2).length - i - 1)
        : bef;
    }, 0);
}; // 첫 번째

var bitwiseComplement = function(N) {
  let X = 1;
  while (N > X) {
    X = X * 2 + 1;
  }
  return X - N;
}; // 두 번째
// 처음에는 숫자를 2진수로 바꾸고, 배열을 돌며 넣고 해당 숫자의 정 반대로 값을 넣어 계속 더해준 뒤에
// 결론적으로 값을 더해주어서 해결하는 방식으로 제작하였다.

// 하지만, 생각은 좀 더 복잡하지만 결론적으론 쉽게 문제를 해결할 수 있다.
// 우리가 구하고자 하는 수는 인자로 들어온 수의 정 반대값,
// 결국 모두 111인 숫자에서 뺏을 때 남는 수라고 볼 수 있다.
// 그러면 주어진 인자보다 큰 가장 작은 이진수로 변환하였을 때, 1로 이루어진 수를 찾으면 된다.
// 계속해서 1로 이루어진 숫자를 찾는 방법은
// 1에 2를 곱하고(이렇게되면 이진수에서는 한자리수를 미루는 것이니(10진수로 보았을 때 10을 곱하는 원리)) 1을 더해준다.
// => X * 2 + 1
// 그러면 11이 완성된다.(3) 그 이후에도 계속해서 이 식을 사용하면 됨.
// 그리고 그 수에서 N의 값을 빼주면 우리가 원하는 값을 얻을 수 있다.
